# module.exports = class UndefinedUnusedVariables
#     rule:
#         name: 'undefined_variables'
#         level: 'error'
#         message: 'Discover undefined variables being used'
#         description: """
#             This rule finds variables that are being used but never actually set
#         """

#     constructor: ->
#         @h = []

#     tokens: [ '=', 'IDENTIFIER', 'INDEX_START', 'INDEX_END', 'TERMINATOR' ]

#     lintToken: (token, tokenApi) ->
#         [type, value, lineNumber] = token
#         return { context: "whats up?" }

class Scope
    variables: {}
    parent: null
    name: null
    accessed: false
    declared: false

    constructor: (name, parent) ->
        @name = name
        @parent = parent
        # @variables = var

    hasVar: (name) ->
        return @variables.hasOwnProperty name

    addVar: (varInfo) ->
        @variables[name] = varInfo

    declaredInScope: (scope = @parent, token) ->
        if @hasVar(token)
            return true
        if @parent is null
            return false
        return @declaredInScope(scope.parent, token)

module.exports = class UndefinedUnusedVariables

    rule:
        name: 'undefined_variables'
        level: 'error'
        message: 'Discover undefined variables being used'
        description: """
            This rule finds variables that are being used but never actually set
        """

    tokens: [ '=', 'IDENTIFIER', 'PARAM_START', 'PARAM_END', 'INDEX_START', 'INDEX_END', 'TERMINATOR' ]

    ecmaIdentifiers: [
        "Array",
        "Boolean",
        "Date",
        "decodeURI",
        "decodeURIComponent",
        "encodeURI",
        "encodeURIComponent",
        "Error",
        "eval",
        "EvalError",
        "Function",
        "hasOwnProperty",
        "isFinite",
        "isNaN",
        "Math",
        "Number",
        "Object",
        "parseInt",
        "parseFloat",
        "RangeError",
        "ReferenceError",
        "RegExp",
        "String",
        "SyntaxError",
        "TypeError",
        "URIError",
    ]
    constructor: ->
        @scope = new Scope('GLOBAL', '000000')
        @currentScope = @scope
        # @scope = {
        #     '1_global': { '1_name': '1_global', '0_parent': '00000' }
        # }
        # @currentScope = @scope['1_global']
        @inIndex = false
        @inParam = false
        @funcDepth = 0

        # @tabl = {}

    trackIndex: (type) ->
        if type is 'INDEX_START'
            @inIndex = true
        if type is 'INDEX_END'
            @inIndex = false

    trackParam: (type) ->
        if type is 'PARAM_START'
            @inParam = true
        else
            @inParam = false

    findErrors: ->
        for own varname, varval of @currentScope.variables
            if varval.declared is false
                return { context: "variable #{varname} in #{@currentScope['1_name']} was not declared" }
            if varval.accessed is false
                return { context: "variable #{varname} in #{@currentScope['1_name']} was unused" }

    lintToken: (token, tokenApi) ->
        [type, value, lineNumber] = token
        # console.log [type, value]
        unless tokenApi.peek(1)?
            console.log "TOKTOK: ", token
        if type is 'TERMINATOR'
            context = ""
            undeclared = []
            unaccessed = []
            # console.log "otkL: ", token, @funcDepth
            if @funcDepth > 0
                b = -1
                while (v = tokenApi.peek(b))
                    if v[0] is 'OUTDENT'
                        # console.log("end of a func", @currentScope['1_name'], @currentScope, @scope['1_global'])
                        # console.log "SCOPETERM: ", @currentScope
                        for own varname, varval of @currentScope.variables when varname not in @ecmaIdentifiers
                            if varval.declared is false
                                undeclared.push(varname)
                                # return { context: "variable #{varname} in #{@currentScope['1_name']} was not declared" }
                            if varval.accessed is false
                                unaccessed.push(varname)
                                # return { context: "variable #{varname} in #{@currentScope['1_name']} was unused" }

                        # @currentScope = @currentScope['0_parent']
                        @currentScope = @currentScope.parent
                        @funcDepth--
                        b--
                    else
                        break

            else
                # console.log "KEWL:", lineNumber.last_line is (tokenApi.lines.length - 2) , lineNumber.last_line , (tokenApi.lines.length - 2)
                if lineNumber.last_line is (tokenApi.lines.length - 2) and lineNumber.first_column isnt 0
                    # console.log "KEWL:", token, lineNumber.last_line, (tokenApi.lines.length - 2)
                    # console.log tokenApi.tokensByLine
                    console.log "SCOPE: ", @currentScope
                    for own varname, varval of @currentScope.variables when varname not in @ecmaIdentifiers
                        if varval.declared is false
                            undeclared.push(varname)
                            # return { context: "variable #{varname} in #{@currentScope['name']} was not declared" }
                        if varval.accessed is false
                            unaccessed.push(varname)
                            # return { context: "variable #{varname} in #{@currentScope['name']} was unused" }

            if undeclared.length > 0
                context += "Variables: " + undeclared.join(", ") + " were not declared"

            if unaccessed.length > 0
                context += "Variables: " + unaccessed.join(", ") + " were unused"
            if context isnt ""
                return { context }

                # console.log "tokApi: ", tokenApi

        # keep track of indices
        if type in ['INDEX_START', 'INDEX_END']
            console.log "ipeek: ", tokenApi.peek(1)
            @trackIndex type
            return

        # keep track of being inside parameters (of a function).
        if type in ['PARAM_START', 'PARAM_END']
            # console.log "ppeek: ", tokenApi.peek(1)
            @trackParam type
            return

        if type is "="
            # console.log("there?", tokenApi.peek(-1))
            if tokenApi.peek(-1)[0] is "]"
                console.log("here")
                d = 2
                while (t = tokenApi.peek(-d))
                    if t[0] is 'TERMINATOR' or t[0] is "]"
                        break
                    if t[0] is 'IDENTIFIER' and t.variable is true
                        console.log t[1], "ISCOOL"
                        @currentScope.variables[t[1]].declared = true
                    d++
        # if this is a "legit" variable and we're not inside parameters ()
        if type is 'IDENTIFIER' and not @inParam and token.variable is true
            # If the code is trying to access an indice by variable but variable
            # has not been defined. It cannot be used.
            # if @inIndex and not @currentScope[token[1]]
            # console.log "cS:", @currentScope
            if @inIndex and not @currentScope.hasVar(token[1])
                # console.log("ERROR: ", token[1], "used but not defined")
                return { context: "#{token[1]} used but not defined" }

            # if the token has been defined before in this scope, then set its
            # accessed property to true. otherwise create a new token in the
            # current scope
            # if (token[1] of @currentScope)
            # console.log @currentScope, token[1]
            if (@currentScope.hasVar(token[1]))
                # @currentScope[token[1]].accessed = true
                @currentScope.variables[token[1]].accessed = true
            else
                # @currentScope[token[1]] = { name: token[1], accessed: false, declared: @inParam }
                @currentScope.variables[token[1]] = new Scope(token[1]) # { name: token[1], accessed: false, declared: @inParam }
                @currentScope.variables[token[1]].accessed = false
                @currentScope.variables[token[1]].declared = @inParam

            c = 1
            while (t = tokenApi.peek(c))
                if t[0] not in ['IDENTIFIER', '.']
                    if t[0] is '='
                        # @currentScope[token[1]].declared = true
                        @currentScope.variables[token[1]].declared = true
                        if tokenApi.peek(c + 1)[0] in ['PARAM_START', '->']
                            if tokenApi.peek(c + 1)[0] is 'PARAM_START'
                                r = c + 2
                                while (tokenApi.peek(r)[0] in ['PARAM_END', ',', 'IDENTIFIER'])
                                    r++

                                # console.log tokenApi.peek(r)
                                if tokenApi.peek(r)[0] is '->'
                                    console.log("MADE IT")
                                else
                                    return

                            # @currentScope[token[1]].accessed = false
                            @currentScope.variables[token[1]].accessed = false
                            @funcDepth++
                            # @scope[token[1]] ?= {}
                            # @scope[token[1]]['0_parent'] = @currentScope
                            # @scope[token[1]]['1_name'] = token[1]
                            # @currentScope = @scope[token[1]]

                            @scope.variables[token[1]] = new Scope(token[1]) # { name: token[1], accessed: false, declared: @inParam }
                            @scope.variables[token[1]].accessed = false
                            @scope.variables[token[1]].declared = @inParam
                            @currentScope = @scope#.variables[token[1]]

                            console.log("starting scope for ", token[1], @currentScope)
                        break
                    else
                        break
                c++
            if tokenApi.peek(c)[0] is 'CALL_START'
                if token.variable is true
                    r++
                    # console.log("fn call:", token[0], token[1], @currentScope[token[1]], @declaredInParent(@currentScope['0_parent'], token[1]))
                    # if token[1] of @currentScope and @declaredInParent(@currentScope['0_parent'], token[1])
                    if token[1] of @currentScope.variables and @currentScope?.declaredInScope(@currentScope, token[1])
                        # @currentScope[token[1]].declared = true
                        # @currentScope[token[1]].accessed = true
                        @currentScope.variables[token[1]].declared = true
                        @currentScope.variables[token[1]].accessed = true
                    # @currentScope[token[1]]
                    # console.log "CHURCH", tokenApi.peek(c), token, @currentScope
                else
                    delete @currentScope.variables[token[1]]

        return

    declaredInParent: (scope, token) ->
        unless scope?
            return false
        if scope[token]
            return true
        if scope['0_parent'] is '00000'
            return false
        return @declaredInParent(scope['0_parent'], token)
    # grabIdent: (token, tokenApi) ->
    #     { i: idx } = tokenApi
    #     # if tokenApi.peek(i)
    #     for i in [1..idx] when tokenApi.peek(-i)?[0] is 'IDENTIFIER'
    #         console.log("VAR IS: ", tokenApi.peek(-i)[1])
    #         break

